name: CyberSentry Bot

on:
  workflow_dispatch:  # Trigger manually for instant hacking
  schedule:
    - cron: '*/15 * * * *'  # Run every 15 minutes to reduce resource usage
  push:
    paths:
      - 'writeup-watcher-v6.py'  # Run only if bot script changes
      - 'requirements.txt'     # Run if dependencies change

jobs:
  run-cyber-bot:
    runs-on: ubuntu-latest
    timeout-minutes: 30  # 30-minute timeout to stay lean and mean

    steps:
    - name: Checkout the arsenal
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for stealth commits

    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: 3.11

    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install hacking tools
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Repair JSON files
      run: |
        python3 -c "
        import json
        import os
        import filelock
        import random
        import shutil
        files = [
            ('twitter_urls.json', []),
            ('medium_urls.json', []),
            ('stored_urls.json', []),
            ('medium_posts.json', []),
            ('medium_cache.json', {})
        ]
        for file_path, default_data in files:
            for attempt in range(10):  # Increased retries
                try:
                    with filelock.FileLock(f'{file_path}.lock', timeout=60):
                        if os.path.exists(file_path):
                            shutil.copy(file_path, f'{file_path}.bak')  # Backup before repair
                        if not os.path.exists(file_path):
                            with open(file_path, 'w') as f:
                                json.dump(default_data, f)
                            print(f'Initialized {file_path}')
                        else:
                            try:
                                with open(file_path, 'r') as f:
                                    json.load(f)
                            except json.JSONDecodeError:
                                print(f'Repairing {file_path} due to invalid JSON')
                                with open(file_path, 'w') as f:
                                    json.dump(default_data, f)
                        break
                except filelock.Timeout:
                    jitter = random.uniform(0, 0.5)
                    print(f'Failed to acquire lock for {file_path} (attempt {attempt + 1}/10)')
                    if attempt == 9:
                        print(f'Failed to acquire lock for {file_path} after 10 attempts')
                        raise
                    time.sleep(1 + jitter)
        "

    - name: Debug JSON Content Before Run
      run: |
        echo "twitter_urls.json:"
        cat twitter_urls.json || echo "File is empty or does not exist"
        echo "medium_urls.json:"
        cat medium_urls.json || echo "File is empty or does not exist"
        echo "stored_urls.json:"
        cat stored_urls.json || echo "File is empty or does not exist"
        echo "medium_posts.json:"
        cat medium_posts.json || echo "File is empty or does not exist"

    - name: Run the CyberSentry bot
      env:
        TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
      run: |
        python3 -u writeup-watcher-v6.py > bot_logs.txt 2>&1 || echo "Bot execution failed, check bot_logs.txt"

    - name: Debug JSON Content After Run
      run: |
        echo "twitter_urls.json:"
        cat twitter_urls.json || echo "File is empty or does not exist"
        echo "medium_urls.json:"
        cat medium_urls.json || echo "File is empty or does not exist"
        echo "stored_urls.json:"
        cat stored_urls.json || echo "File is empty or does not exist"
        echo "medium_posts.json:"
        cat medium_posts.json || echo "File is empty or does not exist"

    - name: Clean old cache entries
      run: |
        python3 -c "
        import json
        import time
        import filelock
        import os
        import random
        import shutil
        CACHE_FILE = 'medium_cache.json'
        CACHE_EXPIRY = 86400  # 24 hours
        for attempt in range(10):  # Increased retries
            try:
                with filelock.FileLock(f'{CACHE_FILE}.lock', timeout=60):
                    if os.path.exists(CACHE_FILE):
                        shutil.copy(CACHE_FILE, f'{CACHE_FILE}.bak')  # Backup cache
                    if not os.path.exists(CACHE_FILE):
                        with open(CACHE_FILE, 'w') as f:
                            json.dump({}, f)
                        print(f'Initialized {CACHE_FILE}')
                    else:
                        try:
                            with open(CACHE_FILE, 'r') as f:
                                cache = json.load(f)
                            current_time = time.time()
                            cleaned_cache = {k: v for k, v in cache.items() if (current_time - v['timestamp']) < CACHE_EXPIRY}
                            with open(CACHE_FILE, 'w') as f:
                                json.dump(cleaned_cache, f)
                            print(f'Cleaned {len(cache) - len(cleaned_cache)} old cache entries.')
                        except json.JSONDecodeError:
                            print(f'Repairing {CACHE_FILE} due to invalid JSON.')
                            with open(CACHE_FILE, 'w') as f:
                                json.dump({}, f)
                    break
            except filelock.Timeout:
                jitter = random.uniform(0, 0.5)
                print(f'Failed to acquire lock for {CACHE_FILE} (attempt {attempt + 1}/10)')
                if attempt == 9:
                    print(f'Failed to acquire lock for {CACHE_FILE} after 10 attempts')
                    raise
                time.sleep(1 + jitter)
        "

    - name: Commit and push intel
      uses: stefanzweifel/git-auto-commit-action@v5
      with:
        commit_message: "CyberSentry: Updated URL, post, and cache files"
        file_pattern: "twitter_urls.json medium_urls.json stored_urls.json medium_posts.json medium_cache.json bot_logs.txt"
        commit_user_name: "CyberSentry[bot]"
        commit_user_email: "cybersentry@users.noreply.github.com"
        commit_author: "CyberSentry <cybersentry@users.noreply.github.com>"
        skip_dirty_check: false

    - name: Notify mission status
      if: always()  # Run even if previous steps fail
      env:
        TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        python3 -c "
        import telegram
        import asyncio
        async def send_notification():
            try:
                bot = telegram.Bot(token='$TELEGRAM_TOKEN')
                status = 'Success' if '${{ job.status }}' == 'success' else 'Failed'
                message = f'ðŸŽ¯ CyberSentry Mission Report ðŸŽ¯\nStatus: {status}\nTime: ${{ github.event.schedule || 'Manual' }}\nNew intel committed to the vault.'
                await bot.send_message(chat_id='$TELEGRAM_CHAT_ID', text=message, parse_mode='Markdown')
            except Exception as e:
                print(f'Failed to send Telegram notification: {e}')
        asyncio.run(send_notification())
        "
